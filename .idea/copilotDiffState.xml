<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# TravelCorp ETL&#10;&#10;TravelCorp es un pipeline ETL (Extract, Transform, Load) que recopila, procesa y almacena información meteorológica y financiera de varias ciudades del mundo. El sistema genera alertas automáticas y notificaciones por email en caso de condiciones climáticas extremas o variaciones significativas en el tipo de cambio.&#10;&#10;## Características principales&#10;- Extracción de datos meteorológicos (Open-Meteo) y financieros (ExchangeRate-API) para ciudades configuradas.&#10;- Procesamiento y transformación de datos para generar alertas y un índice de vulnerabilidad (IVV).&#10;- Almacenamiento de resultados en un archivo `output.json` de forma acumulativa.&#10;- Envío de emails automáticos ante alertas de severidad alta.&#10;- Ejecución periódica y logs estructurados con timestamps.&#10;&#10;## Estructura del proyecto&#10;```&#10;TravelCorp/&#10;├── main.py                # Script principal, ejecuta el pipeline ETL periódicamente&#10;├── scheduler.py           # (Opcional) Lógica de scheduling&#10;├── config/                # Configuración general y constantes&#10;│   ├── constants.py       # Ciudades y parámetros principales&#10;│   ├── settings.py        # Configuración de tiempos y parámetros globales&#10;│   └── ...&#10;├── etl/                   # Lógica ETL&#10;│   ├── extract.py         # Extracción de datos de APIs externas&#10;│   ├── transform.py       # Generación de alertas y cálculo de IVV&#10;│   ├── load.py            # Integración de datos y disparo de emails&#10;│   └── ...&#10;├── models/                # Modelos de datos&#10;│   └── open_meteo_response.py&#10;├── utils/                 # Utilidades auxiliares&#10;│   └── email.py           # Envío de emails&#10;├── requirements.txt       # Dependencias del proyecto&#10;└── README.md              # Este archivo&#10;```&#10;&#10;## Instalación&#10;1. Clona el repositorio y entra en la carpeta del proyecto.&#10;2. Crea y activa un entorno virtual:&#10;   ```bash&#10;   python3 -m venv venv&#10;   source venv/bin/activate&#10;   ```&#10;3. Instala las dependencias:&#10;   ```bash&#10;   pip install -r requirements.txt&#10;   ```&#10;&#10;## Configuración&#10;1. Crea un archivo `.env` en la raíz del proyecto con las siguientes variables para el envío de emails:&#10;   ```env&#10;   EMAIL_ADDRESS=tu_email@gmail.com&#10;   EMAIL_APP_PASSWORD=tu_contraseña_de_aplicación&#10;   ```&#10;2. (Opcional) Ajusta las ciudades y parámetros en `config/constants.py` y `config/settings.py`.&#10;&#10;## Ejecución&#10;Para iniciar el pipeline ETL de forma continua:&#10;```bash&#10;python main.py&#10;```&#10;Los resultados se almacenarán en `output.json` y se enviarán emails ante alertas de severidad alta.&#10;&#10;## APIs utilizadas&#10;- **Open-Meteo**: Datos meteorológicos diarios y actuales.&#10;- **ExchangeRate-API**: Tipos de cambio de monedas respecto al USD.&#10;&#10;## Alertas y notificaciones&#10;El sistema genera alertas automáticas cuando:&#10;- Hay condiciones climáticas extremas (temperaturas fuera de rango, alta precipitación, viento fuerte).&#10;- Se detectan variaciones significativas en el tipo de cambio.&#10;Las alertas de severidad alta disparan un email automático al destinatario configurado.&#10;&#10;## Dependencias principales&#10;- `requests`&#10;- `python-dotenv`&#10;- `smtplib` (incluido en la librería estándar)&#10;&#10;## Licencia&#10;MIT&#10;&#10;---&#10;Desarrollado por TravelCorp.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/etl/extract.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/etl/extract.py" />
              <option name="originalContent" value="import random&#10;from datetime import datetime, timezone, timedelta&#10;from typing import Dict, Any&#10;&#10;import requests&#10;&#10;from models.open_meteo_response import WeatherData&#10;&#10;&#10;# ---------------------------------------------------------------&#10;# Primera API &#10;# A. API Meteorológica - Open-Mete&#10;# ---------------------------------------------------------------&#10;&#10;def get_format_timestamp(times_stamp: str) -&gt; str:&#10;    &quot;&quot;&quot;La función get_format_timestamp toma una cadena de fecha y hora (times_stamp) en formato ISO (por ejemplo,&#10;    &quot;2025-08-12T19:30&quot;) y la convierte en un objeto datetime con zona horaria UTC.&#10;    Luego, devuelve esa fecha y hora en formato ISO 8601, incluyendo la información de la zona horaria (+00:00 para UTC).&#10;&#10;    Args:&#10;        times_stamp (str): Dato timesstamp en formato string&#10;&#10;    Returns:&#10;        str: Dato timesstamp en formato ISO 8601 con zona horaria UTC&#10;    &quot;&quot;&quot;&#10;    fecha_hora = datetime.fromisoformat(times_stamp)&#10;    fecha_hora_utc = fecha_hora.replace(tzinfo=timezone.utc)&#10;    timestamp_formateado = fecha_hora_utc.isoformat()&#10;&#10;    return timestamp_formateado&#10;&#10;&#10;def get_pronostico_siete_dias(data_meteorology: Dict[str, Any]) -&gt; Dict:&#10;    &quot;&quot;&quot;La función get_pronostico_siete_dias toma como entrada un diccionario con datos meteorológicos (de la API Open-Meteo)&#10;     y construye una lista de diccionarios, cada uno representando el pronóstico diario para los próximos 7 días.&#10;&#10;    Args:&#10;        data_meteorology (Dict[str, Any]): datos meteorológicos (de la API Open-Meteo)&#10;&#10;    Returns:&#10;        _type_: Diccionario con el pronóstico de 7 días en el formato solicitado en los requerimientos.&#10;    &quot;&quot;&quot;&#10;&#10;    data_meteorology = WeatherData(**data_meteorology)&#10;    fechas = data_meteorology.daily.time&#10;    temp_minimas = data_meteorology.daily.temperature_2m_min&#10;    temp_maximas = data_meteorology.daily.temperature_2m_max&#10;    probabilidad_precipitacion = data_meteorology.daily.precipitation_probability_max&#10;&#10;    # --- Combinar las listas en el formato deseado ---&#10;    pronostico_7_dias = []&#10;&#10;    # zip() itera sobre todas las listas en paralelo&#10;    for fecha, t_max, t_min, prec in zip(fechas, temp_maximas, temp_minimas, probabilidad_precipitacion):&#10;        dia = {&#10;            &quot;fecha&quot;: fecha,&#10;            &quot;temp_max&quot;: t_max,&#10;            &quot;temp_min&quot;: t_min,&#10;            &quot;precipitacion&quot;: prec&#10;        }&#10;        pronostico_7_dias.append(dia)&#10;&#10;    return pronostico_7_dias&#10;&#10;&#10;def extract_api_meteorology(name_city: str, city: Dict[str, Any], retry: bool = True, max_retries: int = 2) -&gt; Dict[&#10;    str, Any]:&#10;    &quot;&quot;&quot;La función extract_api_meteorology consulta la API meteorológica Open-Meteo para una ciudad específica y devuelve un diccionario con información solicitado del clima en el formato de diccionario solicitado.&#10;&#10;    Raises:&#10;        ValueError: _description_&#10;    &#10;    Args:&#10;        name_city (str): Nombre de la ciudad a buscar la información&#10;        city (Dict[str, Any]): Diccionario con latitud y longitud de la ciudad&#10;&#10;    Returns:&#10;        _type_: Diccionario con la información del clima en el formato solicitado.&#10;    &quot;&quot;&quot;&#10;&#10;    lat = city[&quot;lat&quot;]&#10;    lon = city[&quot;lon&quot;]&#10;&#10;    url_meteo = (&#10;        f&quot;https://api.open-meteo.com/v1/forecast&quot;&#10;        f&quot;?latitude={lat}&amp;longitude={lon}&quot;&#10;        f&quot;&amp;current=temperature_2m,wind_speed_10m&quot;&#10;        f&quot;&amp;daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max,uv_index_max&quot;&#10;        f&quot;&amp;timezone=auto&quot;&#10;        f&quot;&amp;forecast_days=7&quot;&#10;    )&#10;    print(f&quot;{url_meteo=}&quot;)&#10;&#10;    while retry and max_retries &gt; 0:&#10;        try:&#10;            response = requests.get(url_meteo, timeout=30)&#10;            response.raise_for_status()  # Lanza error si status != 200&#10;            data_meteorology = response.json()&#10;            # Validar que el JSON tiene los datos esperados&#10;            if &quot;current&quot; not in data_meteorology:&#10;                raise ValueError(&quot;Respuesta incompleta: falta 'current' en la API&quot;)&#10;&#10;            dict_meteorology = {&#10;                &quot;timestamp&quot;: get_format_timestamp(data_meteorology['current']['time']),&#10;                &quot;ciudad&quot;: name_city,&#10;                &quot;clima&quot;: {&#10;                    &quot;temperatura_actual&quot;: data_meteorology['current']['temperature_2m'],&#10;                    &quot;pronostico_7_dias&quot;: get_pronostico_siete_dias(data_meteorology),&#10;                    &quot;precipitacion&quot;: data_meteorology['daily']['precipitation_probability_max'][0],&#10;                    &quot;viento&quot;: data_meteorology['current']['wind_speed_10m'],&#10;                    &quot;uv&quot;: data_meteorology['daily']['uv_index_max'][0]&#10;                }&#10;            }&#10;&#10;            return dict_meteorology&#10;&#10;        except requests.exceptions.RequestException as e:&#10;            print(f&quot;❌ Error de conexión con la API: {e}&quot;)&#10;        except ValueError as e:&#10;            print(f&quot;⚠️ Datos incompletos o formato inesperado: {e}&quot;)&#10;        except Exception as e:&#10;            print(f&quot; Error inesperado: {e}&quot;)&#10;        retry -= 1&#10;    raise Exception(&quot;❌ No se pudo obtener datos de la API meteorológica después de varios intentos.&quot;)&#10;&#10;&#10;# ---------------------------------------------------------------&#10;#   Segunda API&#10;# B. API de Tipos de Cambio - ExchangeRate-API&#10;# ---------------------------------------------------------------&#10;&#10;def extract_api_exchangerate(city_currency: str, retry: bool = True, max_retries: int = 2) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;La función extract_api_exchangerate consulta la API ExchangeRate-API para obtener información financiera sobre&#10;    el tipo de cambio de una moneda específica respecto al dólar estadounidense (USD) y lo transfomra en un&#10;    diccionario con los requerimints solicitados.&#10;&#10;    Args:&#10;        city_currency (str): Se requiere la nomenclatura de la moneda a consultar, por ejemplo: &quot;BRL&quot; para el Real Brasileño.&#10;&#10;    Returns:&#10;        Dict[str, Any]: se retorno el diccionario con la información financiera solicitada.&#10;    &quot;&quot;&quot;&#10;&#10;    # URL de la API de ExchangeRate-API&#10;    url_exchangerate = (f&quot;https://api.exchangerate-api.com&quot;&#10;                        f&quot;/v4&quot;&#10;                        f&quot;/latest&quot;&#10;                        f&quot;/USD&quot;&#10;                        )&#10;    while retry and max_retries &gt; 0:&#10;        try:&#10;            response = requests.get(url_exchangerate, timeout=30)&#10;            response.raise_for_status()  # Lanza error si status != 200&#10;            data_exchangerate = response.json()&#10;&#10;            # 1. tipo_de_cambio_actual USD/Moneda&#10;            rates = data_exchangerate[&quot;rates&quot;]&#10;&#10;            # 2. Tendecia de los últimos 5 días&#10;            today_rate_brl = data_exchangerate[&quot;rates&quot;][city_currency]&#10;            today_date_str = data_exchangerate[&quot;date&quot;]&#10;            today = datetime.strptime(today_date_str, &quot;%Y-%m-%d&quot;).date()&#10;&#10;            current_rate = today_rate_brl&#10;            historical_variations = []&#10;            historical_data = []&#10;&#10;            # Generar datos simulados para los últimos 5 días&#10;            for i in range(5):&#10;                date = today - timedelta(days=i)&#10;                variation_percent = random.uniform(-2, 2)&#10;                historical_variations.append(variation_percent)&#10;&#10;                # La tasa anterior se calcula a partir de la actual y la variación simulada&#10;                previous_rate = current_rate / (1 + (variation_percent / 100))&#10;                current_rate = previous_rate&#10;&#10;            # Calcular el promedio de las variaciones para la tendencia&#10;            average_variation = sum(historical_variations) / len(historical_variations)&#10;&#10;            if average_variation &lt;= 1.5:&#10;                tendencia = &quot;Estable&quot;&#10;            else:&#10;                tendencia = &quot;Volátil&quot;&#10;&#10;            finanzas = {&#10;                &quot;tipo_de_cambio_actual&quot;: rates[city_currency],&#10;                &quot;variacion_diaria&quot;: average_variation,&#10;                &quot;tendencia_5_dias&quot;: tendencia,&#10;            }&#10;            return finanzas&#10;        except requests.exceptions.RequestException as e:&#10;            print(f&quot;❌ Error de conexión con la API: {e}&quot;)&#10;        max_retries -= 1&#10;    raise Exception(&quot;❌ No se pudo obtener datos de la API de tipos de cambio después de varios intentos.&quot;)&#10;&#10;" />
              <option name="updatedContent" value="import random&#10;from datetime import datetime, timezone, timedelta&#10;from typing import Dict, Any&#10;import logging&#10;import requests&#10;&#10;from models.open_meteo_response import WeatherData&#10;&#10;&#10;# ---------------------------------------------------------------&#10;# Primera API &#10;# A. API Meteorológica - Open-Mete&#10;# ---------------------------------------------------------------&#10;&#10;def get_format_timestamp(times_stamp: str) -&gt; str:&#10;    &quot;&quot;&quot;La función get_format_timestamp toma una cadena de fecha y hora (times_stamp) en formato ISO (por ejemplo,&#10;    &quot;2025-08-12T19:30&quot;) y la convierte en un objeto datetime con zona horaria UTC.&#10;    Luego, devuelve esa fecha y hora en formato ISO 8601, incluyendo la información de la zona horaria (+00:00 para UTC).&#10;&#10;    Args:&#10;        times_stamp (str): Dato timesstamp en formato string&#10;&#10;    Returns:&#10;        str: Dato timesstamp en formato ISO 8601 con zona horaria UTC&#10;    &quot;&quot;&quot;&#10;    fecha_hora = datetime.fromisoformat(times_stamp)&#10;    fecha_hora_utc = fecha_hora.replace(tzinfo=timezone.utc)&#10;    timestamp_formateado = fecha_hora_utc.isoformat()&#10;&#10;    return timestamp_formateado&#10;&#10;&#10;def get_pronostico_siete_dias(data_meteorology: Dict[str, Any]) -&gt; Dict:&#10;    &quot;&quot;&quot;La función get_pronostico_siete_dias toma como entrada un diccionario con datos meteorológicos (de la API Open-Meteo)&#10;     y construye una lista de diccionarios, cada uno representando el pronóstico diario para los próximos 7 días.&#10;&#10;    Args:&#10;        data_meteorology (Dict[str, Any]): datos meteorológicos (de la API Open-Meteo)&#10;&#10;    Returns:&#10;        _type_: Diccionario con el pronóstico de 7 días en el formato solicitado en los requerimientos.&#10;    &quot;&quot;&quot;&#10;&#10;    data_meteorology = WeatherData(**data_meteorology)&#10;    fechas = data_meteorology.daily.time&#10;    temp_minimas = data_meteorology.daily.temperature_2m_min&#10;    temp_maximas = data_meteorology.daily.temperature_2m_max&#10;    probabilidad_precipitacion = data_meteorology.daily.precipitation_probability_max&#10;&#10;    # --- Combinar las listas en el formato deseado ---&#10;    pronostico_7_dias = []&#10;&#10;    # zip() itera sobre todas las listas en paralelo&#10;    for fecha, t_max, t_min, prec in zip(fechas, temp_maximas, temp_minimas, probabilidad_precipitacion):&#10;        dia = {&#10;            &quot;fecha&quot;: fecha,&#10;            &quot;temp_max&quot;: t_max,&#10;            &quot;temp_min&quot;: t_min,&#10;            &quot;precipitacion&quot;: prec&#10;        }&#10;        pronostico_7_dias.append(dia)&#10;&#10;    return {&quot;pronostico_7_dias&quot;: pronostico_7_dias}&#10;&#10;&#10;def extract_api_meteorology(name_city: str, city: Dict[str, Any], retry: bool = True, max_retries: int = 2) -&gt; Dict[&#10;    str, Any]:&#10;    &quot;&quot;&quot;La función extract_api_meteorology consulta la API meteorológica Open-Meteo para una ciudad específica y devuelve un diccionario con información solicitado del clima en el formato de diccionario solicitado.&#10;&#10;    Raises:&#10;        ValueError: _description_&#10;    &#10;    Args:&#10;        name_city (str): Nombre de la ciudad a buscar la información&#10;        city (Dict[str, Any]): Diccionario con latitud y longitud de la ciudad&#10;&#10;    Returns:&#10;        _type_: Diccionario con la información del clima en el formato solicitado.&#10;    &quot;&quot;&quot;&#10;&#10;    lat = city[&quot;lat&quot;]&#10;    lon = city[&quot;lon&quot;]&#10;&#10;    url_meteo = (&#10;        f&quot;https://api.open-meteo.com/v1/forecast&quot;&#10;        f&quot;?latitude={lat}&amp;longitude={lon}&quot;&#10;        f&quot;&amp;current=temperature_2m,wind_speed_10m&quot;&#10;        f&quot;&amp;daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max,uv_index_max&quot;&#10;        f&quot;&amp;timezone=auto&quot;&#10;        f&quot;&amp;forecast_days=7&quot;&#10;    )&#10;    logging.info(f&quot;{url_meteo=}&quot;)&#10;&#10;    while retry and max_retries &gt; 0:&#10;        try:&#10;            response = requests.get(url_meteo, timeout=30)&#10;            response.raise_for_status()  # Lanza error si status != 200&#10;            data_meteorology = response.json()&#10;            # Validar que el JSON tiene los datos esperados&#10;            if &quot;current&quot; not in data_meteorology:&#10;                raise ValueError(&quot;Respuesta incompleta: falta 'current' en la API&quot;)&#10;&#10;            dict_meteorology = {&#10;                &quot;timestamp&quot;: get_format_timestamp(data_meteorology['current']['time']),&#10;                &quot;ciudad&quot;: name_city,&#10;                &quot;clima&quot;: {&#10;                    &quot;temperatura_actual&quot;: data_meteorology['current']['temperature_2m'],&#10;                    &quot;pronostico_7_dias&quot;: get_pronostico_siete_dias(data_meteorology),&#10;                    &quot;precipitacion&quot;: data_meteorology['daily']['precipitation_probability_max'][0],&#10;                    &quot;viento&quot;: data_meteorology['current']['wind_speed_10m'],&#10;                    &quot;uv&quot;: data_meteorology['daily']['uv_index_max'][0]&#10;                }&#10;            }&#10;&#10;            return dict_meteorology&#10;&#10;        except requests.exceptions.RequestException as e:&#10;            logging.error(f&quot;❌ Error de conexión con la API: {e}&quot;)&#10;        except ValueError as e:&#10;            logging.warning(f&quot;⚠️ Datos incompletos o formato inesperado: {e}&quot;)&#10;        except Exception as e:&#10;            logging.error(f&quot; Error inesperado: {e}&quot;)&#10;        retry -= 1&#10;    raise Exception(&quot;❌ No se pudo obtener datos de la API meteorológica después de varios intentos.&quot;)&#10;&#10;&#10;# ---------------------------------------------------------------&#10;#   Segunda API&#10;# B. API de Tipos de Cambio - ExchangeRate-API&#10;# ---------------------------------------------------------------&#10;&#10;def extract_api_exchangerate(city_currency: str, retry: bool = True, max_retries: int = 2) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;La función extract_api_exchangerate consulta la API ExchangeRate-API para obtener información financiera sobre&#10;    el tipo de cambio de una moneda específica respecto al dólar estadounidense (USD) y lo transfomra en un&#10;    diccionario con los requerimints solicitados.&#10;&#10;    Args:&#10;        city_currency (str): Se requiere la nomenclatura de la moneda a consultar, por ejemplo: &quot;BRL&quot; para el Real Brasileño.&#10;&#10;    Returns:&#10;        Dict[str, Any]: se retorno el diccionario con la información financiera solicitada.&#10;    &quot;&quot;&quot;&#10;&#10;    # URL de la API de ExchangeRate-API&#10;    url_exchangerate = (f&quot;https://api.exchangerate-api.com&quot;&#10;                        f&quot;/v4&quot;&#10;                        f&quot;/latest&quot;&#10;                        f&quot;/USD&quot;&#10;                        )&#10;    while retry and max_retries &gt; 0:&#10;        try:&#10;            response = requests.get(url_exchangerate, timeout=30)&#10;            response.raise_for_status()  # Lanza error si status != 200&#10;            data_exchangerate = response.json()&#10;&#10;            # 1. tipo_de_cambio_actual USD/Moneda&#10;            rates = data_exchangerate[&quot;rates&quot;]&#10;&#10;            # 2. Tendecia de los últimos 5 días&#10;            today_rate_brl = data_exchangerate[&quot;rates&quot;][city_currency]&#10;            today_date_str = data_exchangerate[&quot;date&quot;]&#10;            today = datetime.strptime(today_date_str, &quot;%Y-%m-%d&quot;).date()&#10;&#10;            current_rate = today_rate_brl&#10;            historical_variations = []&#10;            historical_data = []&#10;&#10;            # Generar datos simulados para los últimos 5 días&#10;            for i in range(5):&#10;                date = today - timedelta(days=i)&#10;                variation_percent = random.uniform(-2, 2)&#10;                historical_variations.append(variation_percent)&#10;&#10;                # La tasa anterior se calcula a partir de la actual y la variación simulada&#10;                previous_rate = current_rate / (1 + (variation_percent / 100))&#10;                current_rate = previous_rate&#10;&#10;            # Calcular el promedio de las variaciones para la tendencia&#10;            average_variation = sum(historical_variations) / len(historical_variations)&#10;&#10;            if average_variation &lt;= 1.5:&#10;                tendencia = &quot;Estable&quot;&#10;            else:&#10;                tendencia = &quot;Volátil&quot;&#10;&#10;            finanzas = {&#10;                &quot;tipo_de_cambio_actual&quot;: rates[city_currency],&#10;                &quot;variacion_diaria&quot;: average_variation,&#10;                &quot;tendencia_5_dias&quot;: tendencia,&#10;            }&#10;            return finanzas&#10;        except requests.exceptions.RequestException as e:&#10;            logging.error(f&quot;❌ Error de conexión con la API: {e}&quot;)&#10;        max_retries -= 1&#10;    raise Exception(&quot;❌ No se pudo obtener datos de la API de tipos de cambio después de varios intentos.&quot;)&#10;&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(asctime)s %(levelname)s %(message)s',&#10;    datefmt='%Y-%m-%d %H:%M:%S'&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="import json&#10;import time&#10;from datetime import date&#10;&#10;from dotenv import load_dotenv&#10;&#10;from config.constants import CITIES&#10;from config.settings import execution_sleep_time&#10;from etl.load import create_list_load_data_cities&#10;&#10;load_dotenv()&#10;&#10;&#10;class DateTimeEncoder(json.JSONEncoder):&#10;    def default(self, obj):&#10;        if isinstance(obj, date):&#10;            return obj.isoformat()&#10;        return super().default(obj)&#10;&#10;&#10;def execute_etl():&#10;    try:&#10;        data_final = create_list_load_data_cities(CITIES)&#10;        output_path = &quot;output.json&quot;&#10;        try:&#10;            with open(output_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as infile:&#10;                existing_data = json.load(infile)&#10;        except (FileNotFoundError, json.JSONDecodeError):&#10;            existing_data = []&#10;        if not isinstance(existing_data, list):&#10;            existing_data = [existing_data]&#10;        existing_data.append(data_final)&#10;        with open(output_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as outfile:&#10;            json.dump(existing_data, outfile, indent=4, ensure_ascii=False, cls=DateTimeEncoder)&#10;    except Exception as e:&#10;        print(f&quot;Error executing ETL process: {e}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    while True:&#10;        execute_etl()&#10;        print(f&quot;Waiting for {execution_sleep_time} seconds before the next execution...&quot;)&#10;        time.sleep(execution_sleep_time)&#10;" />
              <option name="updatedContent" value="import json&#10;import time&#10;from datetime import date&#10;&#10;from dotenv import load_dotenv&#10;&#10;from config.constants import CITIES&#10;from config.settings import execution_sleep_time&#10;from etl.load import create_list_load_data_cities&#10;&#10;load_dotenv()&#10;&#10;import logging&#10;&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(asctime)s %(levelname)s %(message)s',&#10;    datefmt='%Y-%m-%d %H:%M:%S'&#10;)&#10;&#10;&#10;class DateTimeEncoder(json.JSONEncoder):&#10;    def default(self, obj):&#10;        if isinstance(obj, date):&#10;            return obj.isoformat()&#10;        return super().default(obj)&#10;&#10;&#10;def execute_etl():&#10;    try:&#10;        data_final = create_list_load_data_cities(CITIES)&#10;        output_path = &quot;output.json&quot;&#10;        try:&#10;            with open(output_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as infile:&#10;                existing_data = json.load(infile)&#10;        except (FileNotFoundError, json.JSONDecodeError):&#10;            existing_data = []&#10;        if not isinstance(existing_data, list):&#10;            existing_data = [existing_data]&#10;        existing_data.append(data_final)&#10;        with open(output_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as outfile:&#10;            json.dump(existing_data, outfile, indent=4, ensure_ascii=False, cls=DateTimeEncoder)&#10;        logging.info(&quot;Datos ETL guardados correctamente en %s&quot;, output_path)&#10;    except Exception as e:&#10;        logging.error(&quot;Error ejecutando el proceso ETL: %s&quot;, e)&#10;        raise e&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    while True:&#10;        execute_etl()&#10;        logging.info(&quot;Esperando %s segundos antes de la siguiente ejecución...&quot;, execution_sleep_time)&#10;        time.sleep(execution_sleep_time)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>